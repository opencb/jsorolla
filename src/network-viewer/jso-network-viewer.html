<script src="../lib/utils.js"></script>
<script src="../lib/svg.js"></script>

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-list/iron-list.html">

<script src="../../bower_components/d3/d3.min.js"></script>
<script src="../../bower_components/pako/dist/pako.min.js"></script>

<script src="../../bower_components/js-xlsx/dist/jszip.js"></script>
<script src="../../bower_components/js-xlsx/dist/xlsx.min.js"></script>

<script src="../../bower_components/cookies-js/dist/cookies.min.js"></script>
<script src="../../bower_components/crypto-js-evanvosberg/core.js"></script>
<script src="../../bower_components/crypto-js-evanvosberg/sha1.js"></script>
<script src="../../bower_components/highcharts-release/adapters/standalone-framework.js"></script>
<script src="../../bower_components/highcharts-release/highcharts.js"></script>


<script src="../../bower_components/underscore/underscore-min.js"></script>
<script src="../../bower_components/backbone/backbone.js"></script>


<link rel="import" href="../lib/components/network/jso-graph.html">

<script src="../lib/network/point.js"></script>
<script src="../lib/network/edge.js"></script>
<script src="../lib/network/vertex.js"></script>
<!--<script src="../lib/network/default-vertex-renderer.js"></script>-->
<script src="../lib/network/circos-vertex-renderer.js"></script>
<script src="../lib/network/default-edge-renderer.js"></script>
<script src="../lib/network/graph-layout.js"></script>

<script src="../lib/data-adapter/network/attribute-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/json-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/sif-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/text-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/xlsx-network-data-adapter.js"></script>

<script src="../lib/data-source/data-source.js"></script>
<script src="../lib/data-source/file-data-source.js"></script>
<script src="../lib/data-source/string-data-source.js"></script>


<link rel="import" href="../lib/components/jso-panel.html">
<link rel="import" href="../lib/components/table/jso-table.html">
<link rel="import" href="../lib/components/jso-color-picker.html">
<link rel="import" href="../lib/components/jso-color-menu.html">
<link rel="import" href="../lib/components/jso-select-box.html">

<link rel="import" href="jso-nv-bar.html">
<link rel="import" href="jso-nv-tool-bar.html">
<link rel="import" href="jso-nv-edition-bar.html">
<link rel="import" href="jso-nv-status-bar.html">
<link rel="import" href="jso-nv-layout.html">
<link rel="import" href="jso-nv-session-manager.html">

<link rel="import" href="../lib/components/network/jso-sif-network-file-open.html">
<link rel="import" href="../lib/components/network/jso-text-network-file-open.html">
<link rel="import" href="../lib/components/network/jso-xlsx-network-file-open.html">
<link rel="import" href="../lib/components/network/jso-attribute-network-file-open.html">
<link rel="import" href="../lib/components/network/jso-network-edit.html">
<link rel="import" href="../lib/components/network/jso-attribute-edit.html">
<link rel="import" href="../lib/components/network/jso-nv-select-filter.html">
<link rel="import" href="../lib/components/network/render-settings/jso-attribute-node-render.html">
<link rel="import" href="../lib/components/network/render-settings/jso-attribute-edge-render.html">
<link rel="import" href="../lib/components/network/render-settings/jso-attribute-render-number-table.html">
<link rel="import" href="../lib/components/network/render-settings/jso-attribute-render-color-table.html">
<link rel="import" href="../lib/components/network/render-settings/jso-attribute-render-select-table.html">

<link rel="import" href="../lib/components/network/jso-cellbase-xref-import.html">
<link rel="import" href="../lib/components/network/jso-cellbase-functionalities-import.html">
<link rel="import" href="../lib/components/network/jso-cellbase-drugs-import.html">
<link rel="import" href="../lib/components/network/jso-cellbase-diseases-import.html">
<link rel="import" href="../lib/components/network/jso-intact-import.html">
<link rel="import" href="../lib/components/network/jso-communities-structure-detection.html">
<link rel="import" href="../lib/components/network/jso-topological-study.html">
<link rel="import" href="../lib/components/network/jso-kegg.html">
<link rel="import" href="../lib/components/network/jso-reactome.html">
<link rel="import" href="../lib/components/network/jso-configure-force-directed.html">

<link rel="import" href="jso-nv-snow.html">
<link rel="import" href="jso-nv-network-miner.html">
<link rel="import" href="jso-nv-fatigo.html">
<!--<link rel="import" href="jso-nv-reactome-fi.html">-->

<script src="../lib/cellbase-manager.js"></script>
<script src="../lib/opencga-manager.js"></script>

<dom-module id="jso-network-viewer">
    <style>
        :host {
            display: block;
            position: relative;
            background-color: #FFFFFF;
            font-size: 13px;
            font-family: 'Lato', 'Helvetica Neue', Helvetica, Arial, 'sans-serif' !important;
            height: 100%;
        }

        .left-side {
            top: 94px;
            left: 0px;
            position: absolute;
        }

        .right-side {
            top: 94px;
            right: 0px;
            position: absolute;
        }

        jso-nv-layout {
            height: calc(100% - 126px);
        }

        .jso-context {
            min-width: 200px;
            cursor: pointer;
        }

        .attr-context {
            font-size: 13px;
        }

        .attrkey {
            color: #888888;
        }

        .attrvalue {}

        .link {
            text-decoration: none;
            color: inherit;
        }

        .link:hover {
            text-decoration: underline;
        }

        .link:visited {
            color: inherit;
        }

        #sessionManager,
        #sessionManagerPanel {
            width: 500px;
        }

        div.jso-dropdown ul li:hover,
        ul.jso-context li:hover {
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }
    </style>
    <template>

        <jso-nv-bar id="nvbar" lite="{{lite}}" hidden$="{{hideBar}}" columns="{{vertexColumns}}" on-session-start="handleSessionStartMenu" on-session-open="handleSessionOpenMenu" on-session-save="handleSessionSaveMenu" on-session-manage="handleSessionManageMenu"
        on-import-sif="handleImportSifMenu" on-import-text="handleImportTextMenu" on-import-xlsx="handleImportXlsxMenu" on-import-node-attributes="handleImportNodeAttrMenu" on-import-edge-attributes="handleImportEdgeAttrMenu" on-export-sif="handleExportSifMenu"
        on-export-svg="handleExportSvgMenu" on-export-png="handleExportPngMenu" on-export-node-attributes="handleExportNodeAttrMenu" on-export-edge-attributes="handleExportEdgeAttrMenu" on-nodes-select-all="handleSelectMenu" on-nodes-select-first-neighbourhood="handleSelectMenu"
        on-nodes-select-invert="handleSelectMenu" on-edges-select-all="handleSelectMenu" on-edges-select-adjacent="handleSelectMenu" on-network-select-all="handleSelectMenu" on-layout-force-directed="handleLayoutMenu" on-layout-tree="handleLayoutMenu"
        on-layout-configure-force-directed="handleLayoutMenu" on-layout-circle="handleLayoutMenu" on-layout-random="handleLayoutMenu" on-network-edit="handleNetworkEditMenu" on-nodes-edit="handleNodesEditMenu" on-edges-edit="handleEdgesEditMenu" on-nodes-filter="handleNodesFilterMenu"
        on-edges-filter="handleEdgesFilterMenu" on-cellbase="handleCellbaseMenu" on-node-simple-rendering="handleNodeSimpleRenderingMenu" on-node-list-rendering="handleNodeListRenderingMenu" on-edge-simple-rendering="handleEdgeSimpleRenderingMenu" on-reactome="handleReactomeMenu"
        on-kegg="handleKeggMenu" on-intact="handleIntactMenu" on-communities-structure-detection="handleCommunitiesMenu" on-topological-study="handleTopologicalMenu" on-reactome-fi-microarray="handleReactomeFiMenu" on-snow="handleSnowMenu" on-network-miner="handleNetworkMinerMenu"
        on-fatigo="handleFatigoMenu" on-example="handleLoadExampleMenu" on-save="handleSave" on-drugs="handleDrugsMenu" on-diseases="handleDiseasesMenu" on-functionalities="handleFunctionalitiesMenu">
        </jso-nv-bar>

        <jso-nv-tool-bar lite="{{lite}}" hidden$="{{hideToolBar}}" background-color="{{backgroundColor}}" mode="{{mode}}" zoom="{{zoom}}" on-layoutchange="handleLayoutChange" on-selectchange="handleSelectChange" on-rotatechange="handleRotateChange" on-importbackgroundimage="handleImportBackgroundImage"
        on-reset-zoom="handleResetZoom">
        </jso-nv-tool-bar>

        <jso-nv-edition-bar id="editionBar" hidden$="{{hideEditionBar}}" selection-color="{{vertexDefaults.selectionColor}}" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-vertexshape="handleVertexShape" on-vertexopacity="handleVertexOpacity"
        on-vertexsize="handleVertexSize" on-vertexcolor="handleVertexColor" on-vertexstrokesize="handleVertexStrokeSize" on-vertexstrokecolor="handleVertexStrokeColor" on-vertexlabelsize="handleVertexLabelSize" on-vertexsearch="handleVertexSearch" on-vertexnamefield="handleVertexNameField"
        on-edgeshape="handleEdgeShape" on-edgesize="handleEdgeSize" on-edgecolor="handleEdgeColor" on-edgelabelsize="handleEdgeLabelSize" on-edgesearch="handleEdgeSearch" on-edgenamefield="handleEdgeNameField">
        </jso-nv-edition-bar>

        <jso-nv-layout id="networkLayout" mode="{{mode}}" scale="{{scale}}" tx="{{center.x}}" ty="{{center.y}}" zoom="{{zoom}}" graph="{{graph}}" background-color="{{backgroundColor}}" on-createvertex="handleCreateVertex" on-selectvertex="handleSelectVertex"
        on-moveselectedvertices="handleMoveSelectedVertices" on-selectarea="handleSelectArea" on-createedge="handleCreateEdge" on-removevertex="handleRemoveVertex" on-removeedge="handleRemoveEdge" on-leftclickvertex="handleLeftClickVertex" on-selectedge="handleSelectEdge"
        on-leftclickedge="handleLeftClickEdge" on-rightclickvertex="handleRightClickVertex" on-rightclickedge="handleRightClickEdge" on-rightclickbackgroundimage="handleRightClickBackgroundImage">
        </jso-nv-layout>

        <jso-nv-status-bar hidden$="{{hideStatusBar}}" last-loaded-file-name="{{lastLoadedFileName}}" vertices="{{vertices}}" edges="{{edges}}" selected-vertices="{{selectedVertices}}" selected-edges="{{selectedEdges}}" selection-color="{{vertexDefaults.selectionColor}}">
        </jso-nv-status-bar>

        <div class="right-side">

            <jso-panel collapsible movable closable id="nodeRenderPanel">
                <div class="header">
                    Node visualization settings
                </div>
                <jso-attribute-node-render class="container" id="nodeRender" columns="{{vertexColumns}}" items="{{vertices}}" defaults="{{vertexDefaults}}" visual-sets="{{vertexVisualSets}}" on-labelAttribute="handleVertexDefaultLabelAttribute" on-labelsize="handleVertexDefaultLabelSize"
                on-labelpositionx="handleVertexDefaultLabelPositionX" on-labelpositiony="handleVertexDefaultLabelPositionY" on-opacity="handleVertexDefaultOpacity" on-shape="handleVertexDefaultShape" on-color="handleVertexDefaultColor" on-strokecolor="handleVertexDefaultStrokeColor"
                on-size="handleVertexDefaultSize" on-strokesize="handleVertexDefaultStrokeSize" on-area="handleVertexDefaultArea" on-strokeArea="handleVertexDefaultStrokeArea" on-xattribute="handleVertexDefaultXAttribute" on-yattribute="handleVertexDefaultYAttribute">
                </jso-attribute-node-render>
            </jso-panel>

            <jso-panel collapsible movable closable id="edgeRenderPanel">
                <div class="header">
                    Edge visualization settings
                </div>
                <jso-attribute-edge-render class="container" id="edgeRender" columns="{{edgeColumns}}" items="{{edges}}" defaults="{{edgeDefaults}}" visual-sets="{{edgeVisualSets}}" on-labelattribute="handleEdgeDefaultLabelAttribute" on-labelsize="handleEdgeDefaultLabelSize"
                on-opacity="handleEdgeDefaultOpacity" on-shaft="handleEdgeDefaultShaft" on-shape="handleEdgeDefaultShape" on-bidirectional="handleEdgeDefaultBidirectional" on-color="handleEdgeDefaultColor" on-size="handleEdgeDefaultSize">
                </jso-attribute-edge-render>
            </jso-panel>

        </div>
        <div class="left-side">

            <jso-panel hidden collapsible fixed movable closable id="nodeSelectFilterPanel">
                <div class="header">
                    Select nodes by attributes
                </div>
                <jso-nv-select-filter class="container" id="nodeSelectFilter" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" filters="{{vertexDefaults.filters}}" on-invert-selection="selectVerticesInvert" on-remove-selected="removeSelectedVertices">
                </jso-nv-select-filter>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="edgeSelectFilterPanel">
                <div class="header">
                    Select edges by attributes
                </div>
                <jso-nv-select-filter class="container" id="edgeSelectFilter" columns="{{edgeColumns}}" items="{{edges}}" selected="{{selectedEdges}}" filters="{{edgeDefaults.filters}}" on-invert-selection="selectEdgesInvert" on-remove-selected="removeSelectedEdges">
                </jso-nv-select-filter>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="networkEditPanel">
                <div class="header">
                    Edit Network
                </div>
                <jso-network-edit class="container" id="networkEdit" selected-vertices="{{selectedVertices}}" selected-edges="{{selectedEdges}}" vertices="{{vertices}}" edges="{{edges}}" on-remove-selected-edges="removeSelectedEdges" on-remove-selected-vertices="removeSelectedVertices"
                on-add-edge="handleNetworkEditAddEdge" on-add-vertex="handleNetworkEditAddVertex">
                </jso-network-edit>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable expandible constraint id="nodeAttributeEditPanel">
                <div class="header">
                    Edit and filter node attributes
                </div>
                <jso-attribute-edit class="container" id="nodeAttributeEdit" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" on-selectedchange="handleAttributeEditVertexSelectedChange" on-selectall="selectAllVertices" on-deselectall="deselectAllVertices"
                on-update-row="handleVerticesUpdateRow" type="node">
                </jso-attribute-edit>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="edgeAttributeEditPanel">
                <div class="header">
                    Edit and filter edge attributes
                </div>
                <jso-attribute-edit class="container" id="edgeAttributeEdit" columns="{{edgeColumns}}" items="{{edges}}" selected="{{selectedEdges}}" on-selectedchange="handleAttributeEditEdgeSelectedChange" on-selectall="selectAllEdges" on-deselectall="deselectAllEdges"
                on-update-row="handleEdgesUpdateRow" type="edge">
                </jso-attribute-edit>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="cellbaseXrefImportPanel">
                <div class="header">
                    Import external references
                </div>
                <jso-cellbase-xref-import id="cellbaseXrefImport" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns">
                </jso-cellbase-xref-import>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="functionalitiesPanel">
                <div class="header">
                    Import functionalities
                </div>
                <jso-cellbase-functionalities-import id="functionalities" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns">
                </jso-cellbase-functionalities-import>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="drugsPanel">
                <div class="header">
                    Import drugs by gene
                </div>
                <jso-cellbase-drugs-import id="drugs" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" on-apply-color="handleApplyDrugsColor" on-apply-multicolor="handleApplyDrugsMulticolor">
                </jso-cellbase-drugs-import>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="diseasesPanel">
                <div class="header">
                    Import diseases by gene
                </div>
                <jso-cellbase-diseases-import id="drugs" class="container" items="{{vertices}}" columns="{{vertexColumns}}" on-add-columns="handleCellbaseAddColumns" on-apply-multicolor="handleApplyDiseasesMulticolor">
                </jso-cellbase-diseases-import>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="intactImportPanel">
                <div class="header">
                    Network protein connectivity
                </div>
                <jso-intact-import id="intactImport" class="container" items="{{vertices}}" columns="{{vertexColumns}}" selected="{{selectedVertices}}" on-graph="handleIntactGraph">
                </jso-intact-import>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="reactomeImportPanel">
                <div class="header">
                    Reactome import
                </div>
                <jso-reactome id="reactomeImport" class="container" on-graph="handleReactomeGraph">
                </jso-reactome>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="keggImportPanel">
                <div class="header">
                    Kegg import
                </div>
                <jso-kegg id="keggImport" class="container" on-graph="handleKeggGraph">
                </jso-kegg>
            </jso-panel>

            <jso-panel hidden collapsible fixed movable closable id="communitiesStructureDetectionPanel">
                <div class="header">
                    Network analysis: Communities structure detection
                </div>
                <jso-communities-structure-detection id="communitiesStructureDetection" items="{{vertices}}" columns="{{vertexColumns}}" graph="{{graph}}" on-community="handleCommunityAttributes" on-apply-community="handleApplyCommunity" class="container">
                </jso-communities-structure-detection>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="topologicalStudyPanel">
                <div class="header">
                    Network analysis: Topological study
                </div>
                <jso-topological-study id="topologicalStudy" items="{{vertices}}" columns="{{vertexColumns}}" graph="{{graph}}" on-topological="handleTopologicalAttributes" class="container">
                </jso-topological-study>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="configureForceDirectedPanel">
                <div class="header">
                    Force directed layout configuration
                    <a class="link" style="margin-left: 15px;" target="_blank" href="https://github.com/mbostock/d3/wiki/Force-Layout">
                        <i class="fa fa-external-link"></i> about
                    </a>
                </div>
                <jso-configure-force-directed id="configureForceDirected" class="container" vertex-columns="{{vertexColumns}}" edge-columns="{{edgeColumns}}" on-ok="handleForceDirectedConfig">
                </jso-configure-force-directed>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="sessionManagerPanel">
                <div class="header">
                    Session manager
                </div>
                <jso-nv-session-manager class="container" id="sessionManager" user-data="{{userData}}" serialize-version="{{serializeVersion}}">
                </jso-nv-session-manager>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="snowPanel">
                <div class="header">
                    Network enrichment form
                </div>
                <jso-nv-snow id="snow" projects="{{projects}}" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" class="container">
                </jso-nv-snow>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="networkMinerPanel">
                <div class="header">
                    Gene set network enrichment form
                </div>
                <jso-nv-network-miner id="networkMiner" projects="{{projects}}" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" class="container">
                </jso-nv-network-miner>
            </jso-panel>


            <jso-panel hidden collapsible fixed movable closable id="fatigoPanel">
                <div class="header">
                    Single enrichment form
                </div>
                <jso-nv-fatigo id="fatigo" projects="{{projects}}" columns="{{vertexColumns}}" items="{{vertices}}" selected="{{selectedVertices}}" class="container">
                </jso-nv-fatigo>
            </jso-panel>


            <!--<template if="{{selectedMenu == 'reactome-fi-microarray'}}">-->
            <!--<jso-nv-reactome-fi-->
            <!--selectedOption="{{selectedMenu}}"-->
            <!--userData="{{userData}}"-->
            <!--selectedStudy="{{selectedStudy}}"-->
            <!--studies="{{studies}}"-->
            <!--networkViewer="{{}}">-->
            <!--</jso-nv-reactome-fi>-->
            <!--</template>-->


            <!--Menu file-->
            <div style="position:fixed;z-index:10">
                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-sif')}}">
                    <jso-panel modal fixed style>
                        <div class="header">
                            Import a network SIF file
                        </div>
                        <jso-sif-network-file-open class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportSif">
                        </jso-sif-network-file-open>
                    </jso-panel>
                </template>


                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-text')}}">
                    <jso-panel modal fixed>
                        <div class="header">
                            Import a network Text file
                        </div>
                        <jso-text-network-file-open class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportText">
                        </jso-text-network-file-open>
                    </jso-panel>
                </template>


                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-xlsx')}}">
                    <jso-panel modal fixed>
                        <div class="header">
                            Import a network XLSX file
                        </div>
                        <jso-xlsx-network-file-open class="container" selected-menu="{{selectedMenu}}" on-graph="handleImportText">
                        </jso-xlsx-network-file-open>
                    </jso-panel>
                </template>


                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-node-attributes')}}">
                    <jso-panel modal fixed>
                        <div class="header">
                            Import Node attributes file
                        </div>
                        <jso-attribute-network-file-open class="container" selected-menu="{{selectedMenu}}" on-open="handleImportNodeAttr">
                        </jso-attribute-network-file-open>
                    </jso-panel>
                </template>

                <template is="dom-if" if="{{computeSelectedMenu(selectedMenu, 'import-edge-attributes')}}">
                    <jso-panel modal fixed>
                        <div class="header">
                            Import edge attributes file
                        </div>
                        <jso-attribute-network-file-open class="container" selected-menu="{{selectedMenu}}" on-open="handleImportEdgeAttr">
                        </jso-attribute-network-file-open>
                    </jso-panel>
                </template>
            </div>


        </div>

        <ul id="imagecontextmenu" class="jso-context">
            <li on-click="handleContextRemoveBackGroundImage">Remove</li>
        </ul>

        <ul id="vertexcontextmenu" class="jso-context">
            <li on-click="handleContextRemoveVertex">Delete node</li>
            <li on-click="handleContextRemoveSelectedVertices" hidden$="{{checkContextOneSelected(selectedVertices.length)}}">Delete selected nodes</li>
            <li data-divider></li>
            <li on-click="handleContextSelectVerticesNeighbour">Select first neighbour nodes</li>
            <li on-click="handleContextSelectEdgesNeighbour">Select Adjacent edges</li>
            <li data-divider></li>
            <li data-text>
                <u>Attributes</u>
            </li>
            <li data-text>
                <div class="attr-context" class="vertical layout">
                    <template is="dom-repeat" items="{{_lastContextVertexAttributes}}" as="attr">
                        <div data-text>
                            <span class="attrkey">{{attr.key}}</span>:
                            <span class="attrvalue">{{attr.value}}</span>
                        </div>
                    </template>
                </div>
            </li>
        </ul>
        <ul id="edgecontextmenu" class="jso-context">
            <li on-click="handleContextRemoveEdge">Delete edge</li>
            <li on-click="handleContextRemoveSelectedEdges" hidden$="{{checkContextOneSelected(selectedEdges.length)}}">Delete selected edges</li>
            <li data-divider></li>
            <li data-text>
                <u>Attributes</u>
            </li>
            <li data-text>
                <div class="attr-context" class="vertical layout">
                    <template is="dom-repeat" items="{{_lastContextEdgeAttributes}}" as="attr">
                        <div data-text>
                            <span class="attrkey">{{attr.key}}</span>:
                            <span class="attrvalue">{{attr.value}}</span>
                        </div>
                    </template>
                </div>
            </li>
        </ul>

        <jso-graph id="graph" vertices="{{vertices}}" edges="{{edges}}"></jso-graph>

    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-network-viewer',
        properties: {
            mode: {
                type: String,
                value: 'select'
            },
            lite: {
                type: Boolean,
                value: false
            },
            hideBar: {
                type: Boolean,
                value: false
            },
            hideToolBar: {
                type: Boolean,
                value: false
            },
            hideEditionBar: {
                type: Boolean,
                value: false
            },
            hideStatusBar: {
                type: Boolean,
                value: false
            },
            hideNodeRender: {
                type: Boolean,
                value: false
            },
            hideEdgeRender: {
                type: Boolean,
                value: false
            },
            userData: {
                type: Object,
            },
            zoom: {
                type: Number,
                value: 25
            },
            backgroundColor: {
                type: String,
                value: '#FFF'
            },
            vertices: {
                type: Array,
                value: function() {
                    return []
                }
            },
            edges: {
                type: Array,
                value: function() {
                    return []
                }
            },
            scale: {
                type: Number,
            },
            center: {
                type: Object,
                value: function() {
                    return {
                        x: 0,
                        y: 0
                    }
                }
            },
            vertexColumns: {
                type: Array
            },
            edgeColumns: {
                type: Array
            },
            selectedVertices: {
                type: Array
            },
            selectedEdges: {
                type: Array
            },
            selectedMenu: {
                type: String,
                value: ''
            },

            lastLoadedFileName: {
                type: String,
                value: ''
            },
            serializeVersion: {
                type: String,
                value: 'v2'
            },
            saveInProgress: {
                type: Boolean,
                value: false
            },
            bioformats: {
                type: Array
            },
            projects: {
                type: Array
            },
        },
        observers: [
            'selectedVerticesChanged(selectedVertices.splices)',
            'selectedEdgesChanged(selectedEdges.splices)',
            'vertexSelectionColorChanged(vertexDefaults.selectionColor)',
            //            'vAttr.selected': 'handleVertexSelected',
            //            'eAttr.selected': 'handleEdgeSelected',
            //            'vAttr.data': 'handleDataChanged',
        ],
        //                attributes="userData selectedStudy studies jsoHeader "
        checkContextOneSelected: function(length) {
            return length < 2;
        },
        ready: function() {
            var me = this;
            this.serializeKey = 'NV_CURRENT_SESSION' + this.serializeVersion;

            this.graph = this.$.graph;
            this.set('selectedVertices', []);
            this.set('selectedEdges', []);

            this.async(function() {
                var h = 126;
                if (this.hideBar) {
                    h -= 30;
                }
                if (this.hideToolBar) {
                    h -= 32;
                }
                if (this.hideEditionBar) {
                    h -= 32;
                }
                if (this.hideStatusBar) {
                    h -= 32;
                }
                this.$.networkLayout.style.height = "calc(100% - " + h + "px)";
            });

            this.$.nodeRenderPanel.hidden = this.hideNodeRender;
            this.$.edgeRenderPanel.hidden = this.hideEdgeRender;

            document.body.addEventListener('click', function(e) {
                me._hideVertexContextMenu();
                me._hideEdgeContextMenu();
                me.$.imagecontextmenu.style.opacity = "";
                me.$.imagecontextmenu.style.visibility = "";
            });

            this._init();
        },
        _init: function() {
            this.resetZoom();
            this.lastLoadedFileName = "";
            this.backgroundImages = [];
            this.backgroundColor = '#FFF';
            this.vertexDefaults = {
                shape: 'circle',
                size: 40,
                //            color: '#9fc6e7',
                color: '#FFFFFF',
                strokeSize: 2,
                //            strokeColor: '#9fc6e7',
                strokeColor: '#888888',
                area: 1,
                strokeArea: 1,
                opacity: 1,
                labelSize: 12,
                labelColor: '#111111',
                labelPositionX: 0,
                labelPositionY: 0,
                labelAttribute: 'id',
                xAttribute: 'x',
                yAttribute: 'y',
                selectionColor: '#da6d1f',
                filters: []
            };
            this.edgeDefaults = {
                shape: 'directed',
                shaft: 'solid',
                bidirectional: 'false',
                size: 1,
                color: '#888888',
                //            color: '#cccccc',
                opacity: 1,
                labelSize: 0,
                labelColor: '#111111',
                labelAttribute: 'relation',
                filters: []
            };
            this.vertexVisualSets = {
                labelSize: null,
                opacity: null,
                shape: null,
                color: null,
                strokeColor: null,
                size: null,
                strokeSize: null
            };
            this.edgeVisualSets = {
                labelSize: null,
                opacity: null,
                shape: null,
                shaft: null,
                bidirectional: null,
                color: null,
                size: null
            };
            if (this.$) {
                var key;
                for (key in this.vertexVisualSets) {
                    if (this.$.nodeRender) {
                        this.$.nodeRender.$[key].clean();
                    }
                }
                for (key in this.edgeVisualSets) {
                    if (this.$.edgeRender) {
                        this.$.edgeRender.$[key].clean();
                    }
                }
            }
            this._createAttrColumns();
        },
        _createAttrColumns: function() {
            var vertexColumns = [];
            var edgeColumns = [];
            vertexColumns.push({
                name: "id",
                title: "Id",
                type: "text",
                editable: false,
                formula: function(row) {
                    return row.attributes["id"];
                }
            });
            vertexColumns.push({
                name: "name",
                title: "Name",
                type: "text",
                formula: function(row) {
                    return row.attributes["name"];
                }
            });
            //            vertexColumns.push({
            //                defaultValue: "",
            //                name: "x",
            //                title: "x",
            //                type: "string"
            //            });
            //            vertexColumns.push({
            //                defaultValue: "",
            //                name: "y",
            //                title: "y",
            //                type: "string"
            //            });
            edgeColumns.push({
                name: "id",
                title: "Id",
                type: "text",
                editable: false,
                formula: function(row) {
                    return row.attributes["id"];
                }
            });
            edgeColumns.push({
                name: "name",
                title: "Name",
                type: "text",
                formula: function(row) {
                    return row.attributes["name"];
                }
            });
            edgeColumns.push({
                name: "relation",
                title: "Relation",
                type: "text",
                formula: function(row) {
                    return row.attributes["relation"];
                }
            });
            this.set('vertexColumns', vertexColumns);
            this.set('edgeColumns', edgeColumns);
        },
        _restoreColumns: function(jsonColumns) {
            for (var i = 0; i < jsonColumns.length; i++) {
                var column = jsonColumns[i];
                column.formula = function(row) {
                    return row.attributes[this.name];
                }
            }
        },
        handleSave: function() {
            this.saveLocalStorage();
        },
        startOver: function() {
            this.deleteLocalStorage();
            this._init();
            this.$.networkLayout.clean();
            this.graph.clean();
            this.saveLocalStorage();
        },
        resetZoom: function() {
            this.zoom = 25;
            this.set('center.x', 0);
            this.set('center.y', 0);
        },


        loadLocalStorage: function() {
            var item = localStorage.getItem(this.serializeKey);
            if (item !== null && item !== "null") {
                try {
                    this.loadJSON(JSON.parse(pako.ungzip(localStorage.getItem(this.serializeKey), {
                        to: 'string'
                    })));
                } catch (e) {
                    this.deleteLocalStorage();
                    return false;
                }
                return true;
            }
            return false;
        },
        saveLocalStorage: function() {
            if (this.saveInProgress == false) {
                this.saveInProgress = true;
                localStorage.setItem(this.serializeKey, pako.gzip(JSON.stringify(this), {
                    to: 'string'
                }));
                this.saveInProgress = false;
            } else {
                console.log("Save is already in progress");
            }
        },
        deleteLocalStorage: function() {
            //Clean OLD
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key.indexOf('NETWORKVIEWER') != -1) {
                    localStorage.removeItem(key);
                }
            }

            localStorage.setItem(this.serializeKey, null);
            localStorage.removeItem(this.serializeKey);
        },

        loadJSON: function(o) {
            this.startOver();
            //Version fix  selectionColor
            if (o.vertexDefaults.selectionColor == null) {
                o.vertexDefaults.selectionColor = this.vertexDefaults.selectionColor;
            }
            //Version Fix filters
            if (o.vertexDefaults.filters == null) {
                o.vertexDefaults.filters = this.vertexDefaults.filters;
            }
            if (o.edgeDefaults.filters == null) {
                o.edgeDefaults.filters = this.edgeDefaults.filters;
            }
            this.backgroundImages = o.backgroundImages;

            this.backgroundColor = o.backgroundColor;

            //            var graph = new JsoGraph;
            //            graph.fromJSON(o.graph);

            this.graph.fromJSON(o.graph);

            this._createAttrColumns();
            this._restoreColumns(o.vertexColumns);
            this._restoreColumns(o.edgeColumns);

            this._addColumns(o.vertexColumns, 'vertexColumns');
            this._addColumns(o.edgeColumns, 'edgeColumns');

            this.vertexDefaults = o.vertexDefaults;
            this.edgeDefaults = o.edgeDefaults;
            this.vertexVisualSets = o.vertexVisualSets;
            this.edgeVisualSets = o.edgeVisualSets;


            this.refreshGraphView();

            this.saveLocalStorage();

            this.setVertexDefaultLabelAttribute(this.vertexDefaults.labelAttribute);
            this.setEdgeDefaultLabelAttribute(this.edgeDefaults.labelAttribute);
            this.$.networkLayout.addBackgroundImages(this.backgroundImages);
            this.resetZoom();
            this.set('center.x', o.center.x);
            this.set('center.y', o.center.y);
            this.resetZoom();
            this.zoom = o.zoom;
        },

        toJSON: function() {
            return {
                zoom: this.zoom,
                backgroundImages: this.$.networkLayout.getBackgroundImages(),
                backgroundColor: this.backgroundColor,
                center: this.center,
                vertexDefaults: this.vertexDefaults,
                edgeDefaults: this.edgeDefaults,
                vertexVisualSets: this.vertexVisualSets,
                edgeVisualSets: this.edgeVisualSets,
                graph: this.graph,
                vertexColumns: this.vertexColumns,
                edgeColumns: this.edgeColumns,
                version: this.serializeVersion
            };
        },
        /** Display Properties - Attribute Handlers **/
        /** API **/
        setVertexDefaultLabelAttribute: function(attribute) {
            var vertex;
            for (var i = 0, l = this.graph.vertices.length; i < l; i++) {
                vertex = this.graph.vertices[i];
                vertex.renderer.setLabelContent(vertex.attributes[attribute]);
            }
        },
        selectVertexDefaultLabelAttribute: function(attribute) {
            this.vertexDefaults.labelAttribute = attribute;
            this.setVertexDefaultLabelAttribute(attribute);
        },
        setEdgeDefaultLabelAttribute: function(attribute) {
            var edge;
            for (var i = 0, l = this.graph.edges.length; i < l; i++) {
                edge = this.graph.edges[i];
                edge.renderer.setLabelContent(edge.attributes[attribute]);
            }
        },
        selectEdgeDefaultLabelAttribute: function(attribute) {
            this.vertexDefaults.labelAttribute = attribute;
            this.setEdgeDefaultLabelAttribute(attribute);
        },
        setVertexDefaultDisplayProperty: function(displayProperty, value) {
            var splitStr = ",";
            var visualSetEnabled = false;
            var visualSet = this.vertexVisualSets[displayProperty];
            if (visualSet != null && visualSet.enabled) {
                visualSetEnabled = true;
            }
            if (visualSetEnabled == false) {
                var vertex;
                for (var i = 0, l = this.vertices.length; i < l; i++) {
                    vertex = this.graph.vertices[i];
                    vertex.renderer.set(displayProperty, value);
                    this._updateEdgeCoords(vertex);
                }
            } else {
                if (visualSet.parse != 'list') {
                    var vertex, renderValue;
                    for (var i = 0, l = this.vertices.length; i < l; i++) {
                        vertex = this.graph.vertices[i];
                        renderValue = visualSet.matches[vertex.attributes[visualSet.attribute]];
                        if (renderValue != null) {
                            vertex.renderer.set(displayProperty, renderValue);
                        } else {
                            vertex.renderer.set(displayProperty, value);
                        }
                        this._updateEdgeCoords(vertex);
                    }
                } else {
                    var vertex, renderValue, renderValues, finalValues, value, values;
                    for (var i = 0, l = this.vertices.length; i < l; i++) {
                        vertex = this.graph.vertices[i];
                        value = vertex.attributes[visualSet.attribute];
                        if (value == null) {
                            value = "";
                        }
                        values = value.split(splitStr);
                        renderValues = [];
                        for (var j = 0; j < values.length; j++) {
                            renderValue = visualSet.matches[values[j]];
                            if (renderValue != null) {
                                renderValues.push(renderValue);
                            } else {
                                renderValues.push(value);
                            }
                        }
                        finalValues = renderValues;
                        //                            //TODO rework, this is a temporal fix
                        //                            if(displayProperty.indexOf("stroke") == -1){
                        //                                vertex.renderer.pieLabelText = rowValues;
                        //                            }else{
                        //                            }
                        //                            //TODO end
                        vertex.renderer.set(displayProperty, finalValues);
                        this._updateEdgeCoords(vertex);
                    }
                }
            }
        },
        setEdgeDefaultDisplayProperty: function(displayProperty, value) {
            var visualSetEnabled = false;
            var visualSet = this.edgeVisualSets[displayProperty];
            if (visualSet != null && visualSet.enabled) {
                visualSetEnabled = true;
            }
            var edge, finalValue, renderValue;
            for (var i = 0, l = this.edges.length; i < l; i++) {
                edge = this.edges[i];
                finalValue = value;
                if (visualSetEnabled) {
                    renderValue = visualSet.matches[edge.attributes[visualSet.attribute]];
                    if (renderValue != null) {
                        finalValue = renderValue;
                    }
                }
                edge.renderer.set(displayProperty, finalValue);
            }
        },
        setVertexDefaultPositionX: function(attribute, adjust, invertAxis) {
            adjust = (adjust == null) ? true : adjust;
            invertAxis = (invertAxis == null) ? false : invertAxis;
            this._calculateVertexAttributeNormalization(attribute, "x", "width", adjust, invertAxis);
        },
        _calculateVertexAttributeNormalization: function(coordAttr, coord, measure, adjust, invertAxis) {
            var margin = 100,
                midMargin = margin / 2;
            var max, min, c;
            var attributes, vertex;
            for (var i = 0; i < this.graph.vertices.length; i++) {
                vertex = this.graph.vertices[i];
                attributes = vertex.attributes;
                c = parseFloat(attributes[coordAttr]);
                if (!isNaN(c)) {
                    if (!max) {
                        max = c;
                        min = c;
                    }
                    max = Math.max(c, max);
                    min = Math.min(c, min);
                }
            }
            var range = (max === min) ? 1 : max - min;
            if (adjust == false) {
                measure = range;
            } else {
                measure = this.$.networkLayout.getBoundingClientRect()[measure] - margin;
            }
            var attributes, vertex, c;
            for (var i = 0; i < this.graph.vertices.length; i++) {
                vertex = this.graph.vertices[i];
                attributes = vertex.attributes;
                c = parseFloat(attributes[coordAttr]);
                c = (c - min) * measure / range;
                if (invertAxis) {
                    c = measure - c;
                }
                if (!isNaN(c)) {
                    vertex.position[coord] = c + midMargin;
                    vertex.renderer.move();
                    this._updateEdgeCoords(vertex);
                }
            }
        },
        setVertexDefaultPositionY: function(attribute, adjust, invertAxis) {
            adjust = (adjust == null) ? true : adjust;
            invertAxis = (invertAxis == null) ? true : invertAxis;
            this._calculateVertexAttributeNormalization(attribute, "y", "height", adjust, invertAxis);
        },
        /** Handlers **/
        /* Vertex */
        handleVertexDefaultLabelAttribute: function() {
            this.setVertexDefaultLabelAttribute(this.vertexDefaults.labelAttribute);
        },
        handleVertexDefaultLabelSize: function() {
            this.setVertexDefaultDisplayProperty('labelSize', this.vertexDefaults.labelSize);
        },
        handleVertexDefaultLabelPositionX: function() {
            this.setVertexDefaultDisplayProperty('labelPositionX', this.vertexDefaults.labelPositionX);
        },
        handleVertexDefaultLabelPositionY: function() {
            this.setVertexDefaultDisplayProperty('labelPositionY', this.vertexDefaults.labelPositionY);
        },
        handleVertexDefaultOpacity: function() {
            this.setVertexDefaultDisplayProperty('opacity', this.vertexDefaults.opacity);
        },
        handleVertexDefaultShape: function() {
            this.setVertexDefaultDisplayProperty('shape', this.vertexDefaults.shape);
        },
        handleVertexDefaultColor: function() {
            this.setVertexDefaultDisplayProperty('color', this.vertexDefaults.color);
        },
        handleVertexDefaultStrokeColor: function() {
            this.setVertexDefaultDisplayProperty('strokeColor', this.vertexDefaults.strokeColor);
        },
        handleVertexDefaultSize: function() {
            this.setVertexDefaultDisplayProperty('size', this.vertexDefaults.size);
        },
        handleVertexDefaultStrokeSize: function() {
            this.setVertexDefaultDisplayProperty('strokeSize', this.vertexDefaults.strokeSize);
        },
        handleVertexDefaultArea: function() {
            this.setVertexDefaultDisplayProperty('area', this.vertexDefaults.area);
        },
        handleVertexDefaultStrokeArea: function() {
            this.setVertexDefaultDisplayProperty('strokeArea', this.vertexDefaults.strokeArea);
        },
        handleVertexDefaultXAttribute: function() {
            this.setVertexDefaultPositionX(this.vertexDefaults.xAttribute, true, false);
        },
        handleVertexDefaultYAttribute: function() {
            this.setVertexDefaultPositionY(this.vertexDefaults.yAttribute, true, true);
        },
        /* Edge */
        handleEdgeDefaultLabelAttribute: function() {
            this.setEdgeDefaultLabelAttribute(this.edgeDefaults.labelAttribute);
        },
        handleEdgeDefaultLabelSize: function() {
            this.setEdgeDefaultDisplayProperty('labelSize', this.edgeDefaults.labelSize);
        },
        handleEdgeDefaultOpacity: function() {
            this.setEdgeDefaultDisplayProperty('opacity', this.edgeDefaults.opacity);
        },
        handleEdgeDefaultShaft: function() {
            this.setEdgeDefaultDisplayProperty('shaft', this.edgeDefaults.shaft);
        },
        handleEdgeDefaultShape: function() {
            this.setEdgeDefaultDisplayProperty('shape', this.edgeDefaults.shape);
        },
        handleEdgeDefaultBidirectional: function() {
            this.setEdgeDefaultDisplayProperty('bidirectional', this.edgeDefaults.bidirectional);
        },
        handleEdgeDefaultColor: function() {
            this.setEdgeDefaultDisplayProperty('color', this.edgeDefaults.color);
        },
        handleEdgeDefaultSize: function() {
            this.setEdgeDefaultDisplayProperty('size', this.edgeDefaults.size);
        },
        /** END Display Properties - Attribute Handlers **/
        /** ** **/
        /** ** **/
        /** ** **/
        handleAttributeEditVertexSelectedChange: function() {
            this.selectedVerticesChanged();
        },
        handleAttributeEditEdgeSelectedChange: function() {
            this.selectedEdgesChanged();
        },
        handleVerticesUpdateRow: function(e) {
            this.$.nodeRender.refreshAttributes();
            if (e.detail.column.name === this.vertexDefaults.labelAttribute) {
                this.handleVertexDefaultLabelAttribute();
            }
        },
        handleEdgesUpdateRow: function(e) {
            this.$.edgeRender.refreshAttributes();
            if (e.detail.column.name === this.edgeDefaults.labelAttribute) {
                this.handleEdgeDefaultLabelAttribute();
            }
        },
        vertexSelectionColorChanged: function(neo, old) {
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                vertex.renderer.select(this.vertexDefaults.selectionColor);
            }
        },
        selectedVerticesChanged: function(changeRecord) {
            console.time("selectedVerticesChanged")
            if (this.vertices && this.selectedVertices) {
                if (changeRecord) {
                    changeRecord.indexSplices.forEach(function(s) {
                        s.removed.forEach(function(vertex) {
                            vertex.renderer.deselect();
                            console.log(vertex.id + ' deselect');
                        });
                        for (var i = s.index; i < (s.index + s.addedCount); i++) {
                            var vertex = this.selectedVertices[i];
                            vertex.renderer.select(this.vertexDefaults.selectionColor);
                            console.log(vertex.id + ' select');
                        }
                    }, this);
                } else {
                    //Set all not selected
                    for (var i = 0; i < this.vertices.length; i++) {
                        var vertex = this.vertices[i];
                        vertex.renderer.deselect();
                    }
                    //Set selected ones
                    for (var i = 0; i < this.selectedVertices.length; i++) {
                        var vertex = this.selectedVertices[i];
                        vertex.renderer.select(this.vertexDefaults.selectionColor);
                    }
                }
            }
            console.timeEnd("selectedVerticesChanged")
        },
        selectedEdgesChanged: function(changeRecord) {
            //            console.log('selectedEdgesChanged');
            if (this.edges && this.selectedEdges) {
                if (changeRecord) {
                    changeRecord.indexSplices.forEach(function(s) {
                        s.removed.forEach(function(edge) {
                            edge.renderer.deselect();
                            console.log(edge.id + ' deselect');
                        });
                        for (var i = s.index; i < (s.index + s.addedCount); i++) {
                            var edge = this.selectedEdges[i];
                            edge.renderer.select(this.edgeDefaults.selectionColor);
                            console.log(edge.id + ' select');
                        }
                    }, this);
                } else {
                    //Set all not selected
                    for (var i = 0; i < this.edges.length; i++) {
                        var edge = this.edges[i];
                        edge.renderer.deselect();
                    }
                    //Set selected ones
                    for (var i = 0; i < this.selectedEdges.length; i++) {
                        var edge = this.selectedEdges[i];
                        edge.renderer.select(this.edgeDefaults.selectionColor);
                    }
                }
            }
        },

        //        handleDataChanged: function (neo, old) {
        ////                for (var i = 0; i < this.vAttr.data.length; i++) {
        ////                    var row = this.vAttr.data[i];
        ////                    this.setVertexCoords(row.id, parseFloat(row.x), parseFloat(row.y));
        ////                }
        //        },
        /** Bar Handlers **/
        computeSelectedMenu: function(selectedMenu, option) {
            return selectedMenu === option;
        },
        handleNetworkEditMenu: function(e) {
            this.$.networkEditPanel.show();
        },
        handleNodesEditMenu: function(e) {
            this.$.nodeAttributeEditPanel.show();
        },
        handleEdgesEditMenu: function(e) {
            this.$.edgeAttributeEditPanel.show();
        },
        handleNodesFilterMenu: function(e) {
            this.$.nodeSelectFilterPanel.show();
        },
        handleEdgesFilterMenu: function(e) {
            this.$.edgeSelectFilterPanel.show();
        },
        handleCellbaseMenu: function(e) {
            this.$.cellbaseXrefImportPanel.show();
        },
        handleDrugsMenu: function(e) {
            this.$.drugsPanel.show();
        },
        handleDiseasesMenu: function(e) {
            this.$.diseasesPanel.show();
        },
        handleFunctionalitiesMenu: function() {
            this.$.functionalitiesPanel.show();
        },
        handleSessionStartMenu: function(e) {
            if (confirm('All changes will be lost. Are you sure?')) {
                this.startOver();
            }
        },
        handleSessionOpenMenu: function(e) {
            var me = this;
            var file = e.detail.file;
            if (file) {
                var reader = new FileReader();
                reader.onload = function(evt) {
                    try {
                        var jsonStr = pako.ungzip(evt.target.result, {
                            to: 'string'
                        });
                        me.loadJSON(JSON.parse(jsonStr));
                    } catch (err) {
                        console.log('Unable to ungzip');

                        /** **/
                        var stringReader = new FileReader();
                        stringReader.onload = function(evt2) {
                            console.log('Readed as plain text');
                            var jsonStr = evt2.target.result;
                            me.loadJSON(JSON.parse(jsonStr));
                        }
                        stringReader.readAsText(file);
                        /** **/
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        },
        handleSessionSaveMenu: function(e) {
            var isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
            if (isSafari) {
                var content = JSON.stringify(this);
                var blob = new Blob([content], {
                    type: "text/plain;charset=utf-8"
                });
                var initialFileName = 'network.json';

            } else {
                var content = pako.gzip(JSON.stringify(this));
                var blob = new Blob([content], {
                    type: "application/gzip"
                });
                var initialFileName = 'network.json.gz';
            }
            var fileName = window.prompt("Please enter file name", initialFileName);
            if (fileName != null && fileName != "") {
                saveAs(blob, fileName);
            }

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "network.json.gz";
            //            var fileName = window.prompt("Please enter file name", "network.json.gz");
            //            if (fileName != null && fileName != "") {
            //                link.download = fileName;
            //                var event = new MouseEvent('click', {
            //                    'view': window,
            //                    'bubbles': true,
            //                    'cancelable': true
            //                });
            //                link.dispatchEvent(event);
            //            }
        },
        handleSessionManageMenu: function(e) {
            this.$.sessionManagerPanel.show();
        },
        handleImportSifMenu: function(e) {
            this.set('selectedMenu', 'import-sif');
        },
        handleImportTextMenu: function(e) {
            this.selectedMenu = 'import-text';
        },
        handleImportXlsxMenu: function(e) {
            this.selectedMenu = 'import-xlsx';
        },
        handleImportNodeAttrMenu: function(e) {
            this.selectedMenu = 'import-node-attributes';
        },
        handleImportEdgeAttrMenu: function(e) {
            this.selectedMenu = 'import-edge-attributes';
        },
        handleExportSifMenu: function(e) {
            var content = this.exportGraph();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "network.sif");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.target = '_blank';
            //            link.href = url;
            //            link.download = "network.sif";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportNodeAttrMenu: function(e) {
            var content = this.exportVertexAttributes();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "node.attr");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "node.attr";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportEdgeAttrMenu: function(e) {
            var content = this.exportEdgeAttributes();
            var blob = new Blob([content], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, "edge.attr");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "edge.attr";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportSvgMenu: function(e) {
            //                var svg = new XMLSerializer().serializeToString(this.$.networkLayout.$.svg);
            var svg = this.$.networkLayout.$.svgDiv.innerHTML.trim();
            var bcrLayout = this.$.networkLayout.$.drawArea.getBoundingClientRect();
            var toReplace = 'id="svg" width="100%" height="100%"';
            svg = svg.replace(toReplace, 'id="svg" width="' + bcrLayout.width + '" height="' + bcrLayout.height + '"');
            var blob = new Blob([svg], {
                type: "image/svg+xml"
            });
            saveAs(blob, "network.svg");

            //            var url = URL.createObjectURL(blob);
            //            var link = document.createElement('a');
            //            link.href = url;
            //            link.download = "network.svg";
            //            var event = new MouseEvent('click', {
            //                'view': window,
            //                'bubbles': true,
            //                'cancelable': true
            //            });
            //            link.dispatchEvent(event);
        },
        handleExportPngMenu: function(e) {
            //            Deprecated
        },
        handleNodeSimpleRenderingMenu: function(e) {
            this.$.nodeRenderPanel.show();
        },
        handleEdgeSimpleRenderingMenu: function(e) {
            this.$.edgeRenderPanel.show();
        },
        handleReactomeMenu: function(e) {
            this.$.reactomeImportPanel.show();
        },
        handleKeggMenu: function(e) {
            this.$.keggImportPanel.show();
        },
        handleIntactMenu: function(e) {
            this.$.intactImportPanel.show();
        },
        handleCommunitiesMenu: function(e) {
            this.$.communitiesStructureDetectionPanel.show();
        },
        handleTopologicalMenu: function(e) {
            this.$.topologicalStudyPanel.show();
        },
        handleSnowMenu: function(e) {
            if (this.jsoHeader) {
                if (this.jsoHeader.isLogged == false) {
                    this.jsoHeader.anonymousSign();
                }
            }
            this.$.snowPanel.show();
        },
        handleNetworkMinerMenu: function(e) {
            if (this.jsoHeader) {
                if (this.jsoHeader.isLogged == false) {
                    this.jsoHeader.anonymousSign();
                }
            }
            this.$.networkMinerPanel.show();
        },
        handleFatigoMenu: function(e) {
            if (this.jsoHeader) {
                if (this.jsoHeader.isLogged == false) {
                    this.jsoHeader.anonymousSign();
                }
            }
            this.$.fatigoPanel.show();
        },
        handleReactomeFiMenu: function(e) {
            if (this.jsoHeader) {
                if (this.jsoHeader.isLogged == false) {
                    this.jsoHeader.anonymousSign();
                }
            }
            this.$.reactomeFiPanel.show();
        },
        /**/
        handleImportSif: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.set('lastLoadedFileName', e.detail.fileName);
            this.setLayout('Force directed');
            this.saveLocalStorage();
        },
        handleImportText: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.lastLoadedFileName = e.detail.fileName;
            this.setLayout('Force directed');
            this.saveLocalStorage();
        },
        handleImportXlsx: function(e) {
            //                _this.configuration.cleanVisualSets();
            this.setGraph(e.detail.graph);
            this.lastLoadedFileName = e.detail.fileName;
            //                this.$.networkViewer.setLayout(e.detail.layout);
            this.setLayout('Force directed');
            this.saveLocalStorage();
        },
        handleImportNodeAttr: function(e) {
            this.importVertexAttributeManager(e.detail.columns, e.detail.attributes);
        },
        handleImportEdgeAttr: function(e) {
            this.importEdgeAttributeManager(e.detail.columns, e.detail.attributes);
        },
        /** NETWORK **/
        /*SELECT*/
        handleSelectMenu: function(e) {
            switch (e.detail.value) {
                case 'nodes-select-all':
                    this.selectAllVertices();
                    break;
                case 'edges-select-all':
                    this.selectAllEdges();
                    break;
                case 'network-select-all':
                    this.selectAll();
                    break;
                case 'nodes-select-first-neighbourhood':
                    this.selectVerticesNeighbour();
                    break;
                case 'nodes-select-invert':
                    this.selectVerticesInvert();
                    break;
                case 'edges-select-adjacent':
                    this.selectEdgesNeighbour();
                    break;
                default:
                    console.log(e.detail.value + " not defined");
            }
        },
        /*LAYOUT*/
        handleLayoutMenu: function(e) {
            switch (e.detail.value) {
                case 'layout-force-directed':
                    this.setLayout('Force directed');
                    break;
                case 'layout-configure-force-directed':
                    this.$.configureForceDirectedPanel.show();
                    break;
                case 'layout-tree':
                    this.setLayout('Tree');
                    break;
                case 'layout-circle':
                    this.setLayout('Circle', {
                        attributeName: e.detail.subvalue
                    });
                    break;
                case 'layout-random':
                    this.setLayout('Random');
                    break;
                default:
                    console.log(e.detail.value + " not defined");
            }
        },
        /* toolbar Handlers*/
        handleResetZoom: function() {
            this.resetZoom();
        },
        handleImportBackgroundImage: function(e) {
            this.$.networkLayout.addBackgroundImage(e.detail.image);
        },
        handleLayoutChange: function(e) {
            this.setLayout(e.detail.layout);
        },
        handleSelectChange: function(e) {
            this.select(e.detail.select);
        },
        handleRotateChange: function(e) {
            this.rotateNetwork(e.detail.angle);
        },
        /* editionbar Handlers*/
        handleVertexShape: function(e) {
            this.setSelectedVerticesDisplayAttr('shape', e.detail.value, true);
        },
        handleVertexOpacity: function(e) {
            this.setSelectedVerticesDisplayAttr('opacity', e.detail.value);
        },
        handleVertexSize: function(e) {
            this.setSelectedVerticesDisplayAttr('size', parseInt(e.detail.value), true);
        },
        handleVertexColor: function(e) {
            this.setSelectedVerticesDisplayAttr('color', e.detail.value);
        },
        handleVertexStrokeSize: function(e) {
            this.setSelectedVerticesDisplayAttr('strokeSize', parseInt(e.detail.value), true);
        },
        handleVertexStrokeColor: function(e) {
            this.setSelectedVerticesDisplayAttr('strokeColor', e.detail.value);
        },
        handleVertexLabelSize: function(e) {
            this.setSelectedVerticesDisplayAttr('labelSize', e.detail.value);
        },
        handleVertexSearch: function(e) {
            this.selectVerticesByAttribute(e.detail.columnName, e.detail.value);
            if (this.selectedVertices.length == 0) {
                e.detail.inputEl.style.color = '#ff0000';
            }
        },
        handleVertexNameField: function(e) {
            this.setVertexLabel(e.detail.value);
        },
        handleEdgeShape: function(e) {
            this.setSelectedEdgesDisplayAttr('shape', e.detail.value);
        },
        handleEdgeSize: function(e) {
            this.setSelectedEdgesDisplayAttr('size', parseInt(e.detail.value));
        },
        handleEdgeColor: function(e) {
            this.setSelectedEdgesDisplayAttr('color', e.detail.value);
        },
        handleEdgeLabelSize: function(e) {
            this.setSelectedEdgesDisplayAttr('labelSize', e.detail.value);
        },
        handleEdgeSearch: function(e) {
            this.selectEdgesByAttribute(e.detail.columnName, e.detail.value);
        },
        handleEdgeNameField: function(e) {
            this.setEdgeLabel(e.detail.value);
        },
        /** Layout Handlers **/
        handleCreateVertex: function(e) {
            this.createVertex(e.detail.x, e.detail.y);
        },
        handleSelectVertex: function(e) {
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.selectVertex(vertex, e.detail.addToSelection);
        },
        handleSelectEdge: function(e) {
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.selectEdge(edge, e.detail.addToSelection);
        },
        handleMoveSelectedVertices: function(e) {
            this.moveSelectedVertices(e.detail.dispX, e.detail.dispY);
        },
        handleSelectArea: function(e) {
            this.selectByArea(e.detail.x, e.detail.y, e.detail.width, e.detail.height);
        },
        handleCreateEdge: function(e) {
            var source = this.graph.getVertexById(e.detail.sourceId);
            var target = this.graph.getVertexById(e.detail.targetId);
            this.createEdge(source, target);
        },
        handleRemoveVertex: function(e) {
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.removeVertex(vertex);
        },
        handleRemoveEdge: function(e) {
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.removeEdge(edge);
        },
        handleLeftClickVertex: function(e) {
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this.$.editionBar.vertexColor = vertex.renderer.color;
            this.$.editionBar.vertexStrokeColor = vertex.renderer.strokeColor;
            //    this.$.editionBar.vertexNameField = vertex.renderer.labelText;
            this.$.editionBar.vertexSizeField = vertex.renderer.size;
            this.$.editionBar.vertexStrokeSizeField = vertex.renderer.strokeSize;
            this.$.editionBar.selectedBar = 'vertex';
        },
        handleLeftClickEdge: function(e) {
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this.$.editionBar.edgeColor = edge.renderer.color;
            this.$.editionBar.edgeSizeField = edge.renderer.size;
            //                this.$.editionBar.edgeNameField = edge.renderer.labelText;
            this.$.editionBar.selectedBar = 'edge';
        },

        /** Context Handlers **/
        _hideVertexContextMenu: function() {
            this.$.vertexcontextmenu.style.opacity = "";
            this.$.vertexcontextmenu.style.visibility = "";
            this._lastContextVertexAttributes = [];
        },
        _hideEdgeContextMenu: function() {
            this.$.edgecontextmenu.style.opacity = "";
            this.$.edgecontextmenu.style.visibility = "";
            this._lastContextEdgeAttributes = [];
        },
        _showVertexContextMenu: function(x, y) {
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            this.$.vertexcontextmenu.style.opacity = "1";
            this.$.vertexcontextmenu.style.visibility = "visible";
            this.$.vertexcontextmenu.style.top = (bcrnl.top + y + 10) + "px";
            this.$.vertexcontextmenu.style.left = (bcrnl.left + x + 10) + "px";
        },
        _showEdgeContextMenu: function(x, y) {
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            this.$.edgecontextmenu.style.opacity = "1";
            this.$.edgecontextmenu.style.visibility = "visible";
            this.$.edgecontextmenu.style.top = (bcrnl.top + y + 10) + "px";
            this.$.edgecontextmenu.style.left = (bcrnl.left + x + 10) + "px";
        },
        handleRightClickVertex: function(e) {
            this._hideEdgeContextMenu();
            this._lastContextVertexAttributes = [];
            this._showVertexContextMenu(e.detail.x, e.detail.y);
            var vertex = this.graph.getVertexById(e.detail.vertexId);
            this._lastContextVertex = vertex;
            var attrs = [];
            for (var key in vertex.attributes) {
                attrs.push({
                    key: key,
                    value: vertex.attributes[key]
                });
            }
            this._lastContextVertexAttributes = attrs;
        },
        handleRightClickEdge: function(e) {
            this._hideVertexContextMenu();
            this._lastContextEdgeAttributes = [];
            this._showEdgeContextMenu(e.detail.x, e.detail.y);
            var edge = this.graph.getEdgeById(e.detail.edgeId);
            this._lastContextEdge = edge;
            var attrs = [];
            for (var key in edge.attributes) {
                attrs.push({
                    key: key,
                    value: edge.attributes[key]
                });
            }
            this._lastContextEdgeAttributes = attrs;
        },
        handleContextRemoveVertex: function(e) {
            if (confirm('Remove selected vertex?')) {
                this._hideVertexContextMenu();
                this.removeVertex(this._lastContextVertex);
            }
        },
        handleContextRemoveEdge: function(e) {
            if (confirm('Remove selected edge?')) {
                this._hideEdgeContextMenu();
                this.removeEdge(this._lastContextEdge);
            }
        },
        handleContextRemoveSelectedVertices: function(e) {
            if (confirm('Remove selected vertices?')) {
                this._hideVertexContextMenu();
                this.removeSelectedVertices();
            }
        },
        handleContextRemoveSelectedEdges: function(e) {
            if (confirm('Remove selected edges?')) {
                this._hideVertexContextMenu();
                this.removeSelectedEdges();
            }
        },
        handleContextSelectVerticesNeighbour: function(e) {
            this.selectVertex(this._lastContextVertex);
            this.selectVerticesNeighbour();
        },
        handleContextSelectEdgesNeighbour: function(e) {
            this.selectVertex(this._lastContextVertex);
            this.selectEdgesNeighbour();
        },
        _hideImageContextMenu: function() {
            this.$.imagecontextmenu.style.opacity = "";
            this.$.imagecontextmenu.style.visibility = "";
        },
        handleRightClickBackgroundImage: function(e) {
            //                var bcr = e.detail.targetEl.getBoundingClientRect()
            var bcrnl = this.$.networkLayout.getBoundingClientRect();
            //                console.log(bcr)
            //                console.log(bcrnl.top)
            //                console.log(e.detail)
            //                console.log(e.detail.targetEl)
            //                console.log(this.$.networkLayout.targetEl)
            this.$.imagecontextmenu.style.opacity = "1";
            this.$.imagecontextmenu.style.visibility = "visible";
            this.$.imagecontextmenu.style.top = (bcrnl.top + e.detail.y) + "px";
            this.$.imagecontextmenu.style.left = (bcrnl.left + e.detail.x) + "px";
            this._lastImageElClicked = e.detail.targetEl;
        },
        handleContextRemoveBackGroundImage: function(e) {
            this._hideImageContextMenu();
            this.removeBackGroundImage(this._lastImageElClicked);
        },

        /** network edit **/
        handleNetworkEditAddVertex: function(e) {
            var vertex = this.createVertex(null, null, e.detail.id);
        },
        handleNetworkEditAddEdge: function(e) {
            var sourceVertex = this.createVertex(null, null, e.detail.source);
            var targetVertex = this.createVertex(null, null, e.detail.target);
            var edge = this.createEdge(sourceVertex, targetVertex, e.detail.relation);
        },
        /** Cellbase import **/
        handleCellbaseAddColumns: function(e) {
            this._addColumns(e.detail, 'vertexColumns');
        },
        /** IntAct import**/
        handleIntactGraph: function(e) {
            this.setGraph(e.detail.graph);
            this.setLayout('Force directed');
        },
        handleReactomeGraph: function(e) {
            this.startOver();
            this.setGraph(e.detail.graph);
            var cols = [{
                name: "x",
                title: "x",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "y",
                title: "y",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var map = e.detail.map;
            for (var i = 0; i < this.vertices.length; i++) {
                var attributes = this.vertices[i].attributes;
                attributes["name"] = map[attributes["id"]].name;
                attributes["x"] = map[attributes["id"]].x;
                attributes["y"] = map[attributes["id"]].y;
            }
            this._addColumns(cols, 'vertexColumns');

            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            this.handleVertexDefaultXAttribute();
            this.handleVertexDefaultYAttribute();
            this.setLayout("Force directed");
        },
        handleKeggGraph: function(e) {
            this.startOver();
            this.setGraph(e.detail.graph);
            var vertexCols = [{
                name: "x",
                title: "x",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "y",
                title: "y",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }, {
                name: "entryName",
                title: "Entry name",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var edgeCols = [{
                name: "type",
                title: "Type",
                type: "text",
                formula: function(row) {
                    return row.attributes[this.name];
                }
            }];
            var map = e.detail.map;
            for (var i = 0; i < this.vertices.length; i++) {
                var attributes = this.vertices[i].attributes;
                attributes["name"] = map[attributes["id"]].name;
                attributes["entryName"] = map[attributes["id"]].entryName;
                attributes["x"] = map[attributes["id"]].x;
                attributes["y"] = map[attributes["id"]].y;
            }
            this._addColumns(vertexCols, 'vertexColumns');
            this._addColumns(edgeCols, 'edgeColumns');

            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            this.handleVertexDefaultXAttribute();
            this.handleVertexDefaultYAttribute();
            //            me.setLayout("Force directed");

            var matches = {};
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                if (edge.attributes.relation === 'inhibition' || edge.attributes.relation === 'repression') {
                    matches[edge.attributes.relation] = 'inhibited';
                } else if (edge.attributes.relation === 'binding/association') {
                    matches[edge.attributes.relation] = 'undirected';
                } else {
                    matches[edge.attributes.relation] = 'directed';
                }
            }
            // for (var i = 0; i < this.edges.length; i++) {
            //     var edge = this.edges[i];
            //     if (edge.attributes.relation === 'inhibition' || edge.attributes.relation === 'repression') {
            //         matches[edge.attributes.relation] = 'red';
            //     } else if (edge.attributes.relation === 'binding/association') {
            //         matches[edge.attributes.relation] = 'blue';
            //     } else {
            //         matches[edge.attributes.relation] = 'orange';
            //     }
            // }
            this.$.edgeRender.applyVisualSet({
                attribute: "relation",
                displayProperty: "shape",
                enabled: true,
                matches: matches,
                parse: "string",
                type: "categorical"
            });
            // this.$.edgeRender.applyVisualSet({
            //     attribute: "relation",
            //     displayProperty: "color",
            //     enabled: true,
            //     matches: matches,
            //     parse: "string",
            //     type: "categorical"
            // });
        },
        handleCommunityAttributes: function(e) {
            var attr = e.detail.attributes;
            for (var i = 0; i < attr.length; i++) {
                var obj = attr[i];
                var vertex = this.graph.getVertexById(obj.id);
                var attributes = vertex.attributes;
                attributes["community"] = obj.community;
                attributes["communityColor"] = obj.communityColor;
            }
            this._addColumns(e.detail.columns, 'vertexColumns');
        },
        handleApplyCommunity: function(e) {
            this.vertexDefaults.labelAttribute = "name";
            this.handleVertexDefaultLabelAttribute();

            var nodeRender = this.$.nodeRender;
            nodeRender.applyDirect('communityColor', 'color');
        },
        handleTopologicalAttributes: function(e) {
            var attr = e.detail.attributes;
            for (var i = 0; i < attr.length; i++) {
                var obj = attr[i];
                var vertex = this.graph.getVertexById(obj.id);
                if (vertex != null) {
                    var attributes = vertex.attributes;
                    attributes["degree"] = obj.degree;
                    attributes["betweenness"] = obj.betweenness;
                    attributes["closenessCentrality"] = obj.closenessCentrality;
                    attributes["clusteringCoefficient"] = obj.clusteringCoefficient;
                }
            }
            this._addColumns(e.detail.columns, 'vertexColumns');
        },
        handleApplyDrugsColor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                if (vertex.attributes.drugs === 'none') {
                    matches[vertex.attributes.drugs] = '#FFFFFF';
                } else {
                    matches[vertex.attributes.drugs] = '#FF0000';
                }
            }
            nodeRender.applyVisualSet({
                attribute: "drugs",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "string",
                type: "categorical"
            });
        },
        handleApplyDrugsMulticolor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                var drugs = vertex.attributes.drugs.split(',');
                for (var j = 0; j < drugs.length; j++) {
                    var drug = drugs[j];
                    if (drug === 'none') {
                        matches[drug] = '#FFFFFF';
                    } else {
                        matches[drug] = Utils.randomColor();
                    }
                }
            }
            nodeRender.applyVisualSet({
                attribute: "drugs",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "list",
                type: "categorical"
            });
        },
        handleApplyDiseasesMulticolor: function(e) {
            var nodeRender = this.$.nodeRender;
            var matches = {};
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                var diseases = vertex.attributes.diseases.split(',');
                for (var j = 0; j < diseases.length; j++) {
                    var disease = diseases[j];
                    if (diseases === 'none') {
                        matches[disease] = '#FFFFFF';
                    } else {
                        matches[disease] = Utils.randomColor();
                    }
                }
            }
            nodeRender.applyVisualSet({
                attribute: "diseases",
                displayProperty: "color",
                enabled: true,
                matches: matches,
                parse: "list",
                type: "categorical"
            });
        },
        /**
         /** Methods
         /***********/
        selectAll: function() {
            this.selectAllVertices();
            this.selectAllEdges();
        },
        selectVertex: function(vertex, addToSelection) {
            if (!vertex.renderer.selected) {
                if (addToSelection) {
                    this.push('selectedVertices', vertex);
                } else {
                    this.set('selectedVertices', [vertex]);
                }
            } else {
                if (addToSelection) {
                    this.arrayDelete('selectedVertices', vertex);
                }
            }
        },
        selectAllVertices: function() {
            this.set('selectedVertices', this.graph.vertices.slice());
        },
        deselectAllVertices: function() {
            this.set('selectedVertices', []);
        },
        selectEdge: function(edge, addToSelection) {
            if (!edge.renderer.selected) {
                if (addToSelection) {
                    this.push('selectedEdges', edge);
                } else {
                    this.set('selectedEdges', [edge]);
                }
            } else if (addToSelection) {
                this.arrayDelete('selectedEdges', edge);
            }
        },
        selectAllEdges: function() {
            this.set('selectedEdges', this.graph.edges.slice());
        },
        deselectAllEdges: function() {
            this.set('selectedEdges', []);
        },
        selectVerticesNeighbour: function() {
            var selectedVertices = [];
            var selectedVerticesMap = {};
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                selectedVertices.push(vertex);
                selectedVerticesMap[vertex.id] = vertex;
                for (var j = 0; j < vertex.edges.length; j++) {
                    var edge = vertex.edges[j];
                    if (!selectedVerticesMap[edge.source.id]) {
                        selectedVertices.push(edge.source);
                        selectedVerticesMap[edge.source.id] = edge.source;
                    }
                    if (!selectedVerticesMap[edge.target.id]) {
                        selectedVertices.push(edge.target);
                        selectedVerticesMap[edge.target.id] = edge.target;
                    }
                }
            }
            this.set('selectedVertices', selectedVertices);
        },
        selectEdgesNeighbour: function() {
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                for (var j = 0; j < vertex.edges.length; j++) {
                    var edge = vertex.edges[j];
                    if (!edge.renderer.selected) {
                        this.selectEdge(edge, true);
                    }
                }
            }
        },
        selectVerticesInvert: function() {
            var selected = [];
            for (var i = 0; i < this.graph.vertices.length; i++) {
                var vertex = this.graph.vertices[i];
                if (!vertex.renderer.selected) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        selectEdgesInvert: function() {
            var selected = [];
            for (var i = 0; i < this.graph.edges.length; i++) {
                var edge = this.graph.edges[i];
                if (!edge.renderer.selected) {
                    selected.push(edge.id);
                }
            }
            this.set('selectedEdges', selected);
        },
        selectByArea: function(x, y, width, height) {
            this.deselectAllVertices();
            this.deselectAllEdges();
            if (width > 0 && height > 0) {
                x -= this.center.x;
                y -= this.center.y;
                x /= this.scale;
                y /= this.scale;
                width /= this.scale;
                height /= this.scale;
                var vSelected = [];
                var eSelected = [];
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    if (vertex.position.x >= x && vertex.position.x <= x + width && vertex.position.y >= y && vertex.position.y <= y + height) {
                        vSelected.push(vertex);
                        for (var j = 0; j < vertex.edges.length; j++) {
                            var edge = vertex.edges[j];
                            eSelected.push(edge);
                        }
                    }
                }
                this.set('selectedVertices', vSelected);
                this.set('selectedEdges', eSelected);
            }
        },
        _updateEdgeCoords: function(vertex) {
            for (var i = 0; i < vertex.edges.length; i++) {
                var edge = vertex.edges[i];
                if (vertex === edge.source) {
                    edge.renderer.move();
                }
                if (vertex === edge.target) {
                    edge.renderer.move();
                }
            }
        },
        moveSelectedVertices: function(dispX, dispY) {
            dispX /= this.scale;
            dispY /= this.scale;
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                vertex.position.x += dispX;
                vertex.position.y += dispY;
                vertex.renderer.move();
                this._updateEdgeCoords(vertex);
            }
        },
        selectVerticesByIds: function(vertexIds) {
            var selected = [];
            for (var i = 0; i < vertexIds.length; i++) {
                var id = vertexIds[i];
                var vertex = this.graph.getVertexById(id);
                if (vertex != null) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        selectVerticesByAttribute: function(attributeName, attributeValue) {
            var selected = [];
            for (var i = 0; i < this.graph.vertices.length; i++) {
                var vertex = this.graph.vertices[i];
                if (vertex.attributes[attributeName] === attributeValue) {
                    selected.push(vertex);
                }
            }
            this.set('selectedVertices', selected);
        },
        centerVertex: function(vertex) {
            //                var clientRect = this.$.networkLayout.getBoundingClientRect();
            //                var centerX = clientRect.width / 2;
            //                var centerY = clientRect.height / 2;
            //                this.tx = this.x + (-centerX * (this.scale - 1));
            //                this.ty = this.y + (-centerY * (this.scale - 1));
            //
            //                var dx = centerX - vertex.position.x
            //                var dy = centerY - vertex.position.y;
            //                this.center.x = dx;
            //                this.center.y = dy;
            vertex.position.x = this.center.x;
            vertex.position.y = this.center.y;
            vertex.renderer.move();
        },
        selectEdgesByAttribute: function(attributeName, attributeValue) {
            var selected = [];
            for (var i = 0; i < this.graph.edges.length; i++) {
                var edge = this.graph.edges[i];
                if (edge.attributes[attributeName] === attributeValue) {
                    selected.push(edge);
                }
            }
            this.set('selectedEdges', selected);
        },
        setVertexCoords: function(vertexId, x, y) {
            var vertex = this.graph.getVertexById(vertexId);
            vertex.position.x = x;
            vertex.position.y = y;
            //                row.x = vertex.position.x;
            //                row.y = vertex.position.y;
            vertex.renderer.move();
            this._updateEdgeCoords(vertex);
        },
        removeVertex: function(vertex) {
            this._removeVertex(vertex);
            this.deselectAllVertices();
        },
        _removeVertex: function(vertex) {
            for (var i = 0; i < vertex.edges.length; i++) {
                var edge = vertex.edges[i];
                edge.renderer.remove();
            }
            vertex.renderer.remove();
            this.graph.removeVertex(vertex);
        },
        removeEdge: function(edge) {
            edge.renderer.remove();
            this.graph.removeEdge(edge);
            this.deselectAllEdges();
        },
        removeSelectedVertices: function() {
            for (var i = 0; i < this.selectedVertices.length; i++) {
                var vertex = this.selectedVertices[i];
                this._removeVertex(vertex);
            }
            this.deselectAllVertices();
        },
        removeSelectedEdges: function() {
            var edgesToDelete = [];
            var edgeMap = {};
            for (var i = 0; i < this.selectedEdges.length; i++) {
                var edge = this.selectedEdges[i];
                if (edgeMap[edge.id] != true) {
                    edgeMap[edge.id] = true;
                    edgesToDelete.push(edge);
                    edge.renderer.remove();
                }
            }
            this.graph.removeEdges(edgesToDelete);
        },
        setSelectedVerticesDisplayAttr: function(displayProperty, value, updateEdges) {
            var vertex;
            for (var i = 0, li = this.selectedVertices.length; i < li; i++) {
                vertex = this.selectedVertices[i];
                vertex.renderer.set(displayProperty, value);
                if (updateEdges) {
                    this._updateEdgeCoords(vertex);
                }
            }
        },
        setSelectedEdgesDisplayAttr: function(displayProperty, value) {
            var edge;
            for (var i = 0, li = this.selectedEdges.length; i < li; i++) {
                edge = this.selectedEdges[i];
                edge.renderer.set(displayProperty, value);
            }
        },
        setVertexLabel: function(label) {
            //TODO
            //                if (this.selectedVertices.length == 1) {
            //                    var vertex = this.selectedVertices[0];
            //                    this.network.setVertexLabel(vertex, label);
            //                }
        },
        setEdgeLabel: function(label) {
            //TODO
            //                if (this.selectedEdges.length == 1) {
            //                    var edge = this.selectedEdges[0];
            //                    this.network.setEdgeLabel(edge, label);
            //                }
        },
        createVertex: function(x, y, id) {
            if (x == null) {
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                x = clientRect.width / 2;
            } else {
                x -= this.center.x;
                x /= this.scale;
            }
            if (y == null) {
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                y = clientRect.height / 2;
            } else {
                y -= this.center.y;
                y /= this.scale;
            }
            if (id == null) {
                id = 'n' + Math.floor(Math.random() * (999999 - 100000 + 1));
            }
            /* vertex graph */
            var vertex = new Vertex({
                id: id,
                position: new Point(x, y),
                renderer: new CircosVertexRenderer(this.vertexDefaults)
            });
            vertex.attributes.id = vertex.id;
            vertex.attributes.name = vertex.id;
            var added = this.graph.addVertex(vertex);
            if (added) {
                vertex.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            } else {
                vertex = this.graph.getVertexById(id);
            }
            var label = vertex.attributes[this.vertexDefaults.labelAttribute];
            vertex.renderer.setLabelContent(label);
            return vertex;
        },
        createVertices: function(idList) {
            for (var i = 0; i < idList.length; i++) {
                var id = idList[i];
                this.createVertex(0, 0, id);
            }
        },
        createEdge: function(vertexSource, vertexTarget, relation) {
            if (relation == null) {
                relation = 'e' + Math.floor(Math.random() * (999999 - 100000 + 1));
            }
            var id = vertexSource.id + '_' + relation + '_' + vertexTarget.id
                /* edge graph */
            var edge = new Edge({
                id: id,
                relation: relation,
                source: vertexSource,
                target: vertexTarget,
                renderer: new DefaultEdgeRenderer(this.edgeDefaults)
            });
            edge.attributes.id = edge.id;
            edge.attributes.name = edge.id;
            edge.attributes.relation = edge.relation;
            var added = this.graph.addEdge(edge);
            if (added) {
                edge.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            } else {
                edge = this.graph.getEdgeById(id);
            }
            return edge;
        },
        removeBackGroundImage: function(imageEl) {
            if (imageEl && imageEl.parentNode) {
                imageEl.parentNode.removeChild(imageEl);
            }
        },
        rotateNetwork: function(angle) {
            var intPattern = /^-?\d+$/;
            if (angle && intPattern.test(angle)) {
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                var centerX = clientRect.width / 2;
                var centerY = clientRect.height / 2;
                var vertices = this.graph.vertices;
                var rotationInRadians = angle * Math.PI / 180.0;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    var vertex = vertices[i];
                    var vCoords = vertex.position;
                    //Detect angle and radius using width/2 and height/2 as center
                    var deltaX = vCoords.x - centerX;
                    var deltaY = vCoords.y - centerY;
                    var radius = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                    var delta = deltaY / deltaX;
                    var angleRad = (isNaN(delta)) ? 0 : Math.atan(delta) + rotationInRadians;
                    //Fix Quadrant
                    angleRad = (vCoords.x < centerX) ? angleRad += Math.PI : angleRad;
                    var x = centerX + (radius * Math.cos(angleRad));
                    var y = centerY + (radius * Math.sin(angleRad));
                    //
                    this.setVertexCoords(vertex.id, x, y);
                }
            }
        },
        getOrderedIdsByAttribute: function(attributeName) {
            var type = 'float';
            var checkType = true;
            var values = [];
            var vertex, value, l = this.graph.vertices.length;
            for (var i = 0; i < l; i++) {
                vertex = this.graph.vertices[i];
                value = vertex.attributes[attributeName];
                if (!value) {
                    value = '';
                }
                /* detect number or string */
                if (checkType) {
                    var parseResult = parseFloat(value);
                    if (isNaN(parseResult)) {
                        var type = 'string';
                        checkType = false;
                    }
                }
                /* - - - - - - - - - - - - */
                values.push({
                    id: vertex.id,
                    value: value
                });
            }
            switch (type) {
                case 'float':
                    values.sort(function(a, b) {
                        return parseFloat(a.value) - parseFloat(b.value);
                    });
                    break;
                    /* string */
                default:
                    values.sort(function(a, b) {
                        return (a.value > b.value) - (a.value < b.value);
                    });
            }
            return values;
        },
        setLayout: function(type, e) {
            var me = this;
            this.x = 0;
            this.y = 0;
            var graph = this.graph;
            var dot = graph.getAsDOT();
            var clientRect = this.$.networkLayout.getBoundingClientRect();
            var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
            var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;
            switch (type) {
                case "Circle":
                    if (e && typeof e.attributeName !== 'undefined') {
                        GraphLayout.circle(me, width, height, this.getOrderedIdsByAttribute(e.attributeName));
                    } else {
                        GraphLayout.circle(me, width, height);
                    }
                    break;
                case "Random":
                    GraphLayout.random2d(me, width, height);
                    break;
                case "none":
                    break;
                case "Force directed":
                    GraphLayout.force({
                        network: me,
                        width: width,
                        height: height,
                        end: function(verticesArray) {
                            for (var i = 0, l = verticesArray.length; i < l; i++) {
                                var v = verticesArray[i];
                                me.setVertexCoords(v.id, v.x, v.y);
                            }
                        }
                    });
                    break;
                case "Force directed (simulation)":
                    GraphLayout.force({
                        network: me,
                        width: width,
                        height: height,
                        simulation: true,
                        end: function(verticesArray) {
                            for (var i = 0, l = verticesArray.length; i < l; i++) {
                                var v = verticesArray[i];
                                me.setVertexCoords(v.id, v.x, v.y);
                            }
                        }
                    });
                    break;
                case "Tree":
                    if (this.vAttr.selected.length == 1) {
                        GraphLayout.tree({
                            network: me,
                            width: width,
                            height: height - 100,
                            root: this.graph.getVertexById(this.vAttr.selected[0].id),
                            end: function(verticesArray) {
                                for (var i = 0, l = verticesArray.length; i < l; i++) {
                                    var v = verticesArray[i];
                                    me.setVertexCoords(v.name, -v.x + (width), v.y + 50);
                                }
                            }
                        });
                    } else {
                        alert("Please select only one vertex to use it as root");
                    }
                    break;
                default:
                    console.log(dot);
                    //                var url = "http://bioinfo.cipf.es/utils/ws/rest/network/layout/" + type.toLowerCase() + ".coords";
                    ////                var url = "http://localhost:8080/opencga/rest/utils/network/layout/"+type+".coords";
                    ////                var url = "http://ws-beta.bioinfo.cipf.es/opencga-staging/rest/utils/network/layout/" + type.toLowerCase() + ".coords";
                    //                $.ajax({
                    //                    async: false,
                    //                    type: "POST",
                    //                    url: url,
                    //                    dataType: "json",
                    //                    data: {
                    //                        dot: dot
                    //                    },
                    //                    cache: false,
                    //                    success: function (data) {
                    //                        console.log('Layout back')
                    //                        for (var vertexId in data) {
                    //                            var x = _this.getLayoutWidth() * (0.05 + 0.85 * data[vertexId].x);
                    //                            var y = _this.getLayoutHeight() * (0.05 + 0.85 * data[vertexId].y);
                    //                            _this.setVertexCoords(vertexId, x, y);
                    //                        }
                    //                    },
                    //                    error: function (data) {
                    //                        debugger
                    //                    },
                    //
                    //                });
                    break;
            }
        },
        handleForceDirectedConfig: function(e) {
            var me = this;
            var clientRect = this.$.networkLayout.getBoundingClientRect();
            var width = (clientRect.width == 0) ? window.innerWidth : clientRect.width;
            var height = (clientRect.height == 0) ? window.innerHeight : clientRect.height;

            GraphLayout.force({
                network: this,
                width: width,
                height: height,
                linkDistance: parseFloat(e.detail.linkDistance),
                linkStrength: parseFloat(e.detail.linkStrength),
                charge: parseFloat(e.detail.charge),
                attributes: {
                    linkDistance: e.detail.linkDistanceAttribute,
                    linkStrength: e.detail.linkStrengthAttribute,
                    charge: e.detail.chargeAttribute
                },
                friction: parseFloat(e.detail.friction),
                gravity: parseFloat(e.detail.gravity),
                chargeDistance: parseFloat(e.detail.chargeDistance),

                simulation: false,
                end: function(verticesArray) {
                    for (var i = 0, l = verticesArray.length; i < l; i++) {
                        var v = verticesArray[i];
                        var vertex = me.graph.getVertexById(v.id);
                        vertex.position.x = v.x;
                        vertex.position.y = v.y;
                        vertex.renderer.move();
                        me._updateEdgeCoords(vertex);
                    }
                }
            });
        },
        select: function(option) {
            switch (option) {
                case 'All nodes':
                    this.selectAllVertices();
                    break;
                case 'All edges':
                    this.selectAllEdges();
                    break;
                case 'Everything':
                    this.selectAll();
                    break;
                case 'First neighbour nodes':
                    this.selectVerticesNeighbour();
                    break;
                case 'Invert node selection':
                    this.selectVerticesInvert();
                    break;
                case 'Adjacent edges':
                    this.selectEdgesNeighbour();
                    break;
                default:
                    console.log(option + " not defined");
            }
        },
        exportGraph: function(separator) {
            return this.graph.getAsSIF(separator);
        },
        exportVertexAttributes: function(separator) {
            return this._getAttributesAsFile(this.vertexColumns, this.vertices, separator);
        },
        exportEdgeAttributes: function(separator) {
            return this._getAttributesAsFile(this.edgeColumns, this.edges, separator);
        },
        _getAttributesAsFile: function(columns, items, separator) {
            if (!separator) {
                separator = '\t';
            }
            // Attribute names
            var text = '';
            var lc = columns.length
            text += '#';
            for (var i = 0; i < lc; i++) {
                var attrName = columns[i].name;
                text += attrName + separator;
            }
            text += '\n';
            var item, attr;
            for (var i = 0, l = items.length; i < l; i++) {
                item = items[i];
                for (var j = 0; j < lc; j++) {
                    attr = columns[j].name;
                    text += item.attributes[attr] + separator;
                }
                text += '\n';
            }
            return text;
        },
        setGraph: function(graph) {
            this.refreshGraphView(graph);
            this._createAttrColumns();
            this.graph.load(graph);
        },
        refreshGraphView: function(graph) {
            if (graph == null) {
                graph = this.graph;
            }

            this.$.networkLayout.clean();
            this.$.networkLayout.removeDom();

            var edges = graph.edges;
            var vertices = graph.vertices;
            for (var i = 0, l = vertices.length; i < l; i++) {
                var vertex = vertices[i];
                vertex.attributes.id = vertex.id;
                if (vertex.attributes.name == null) {
                    vertex.attributes.name = vertex.id;
                }
                //                    vertex.setRenderer(new CircosVertexRenderer(this.vertexDefaults));
                vertex.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            }
            for (var i = 0, l = edges.length; i < l; i++) {
                var edge = edges[i];
                edge.attributes.id = edge.id;
                if (edge.attributes.relation == null) {
                    edge.attributes.relation = edge.relation;
                }
                if (edge.attributes.name == null) {
                    edge.attributes.name = edge.id;
                }
                //                    edge.setRenderer(new DefaultEdgeRenderer(this.edgeDefaults));
                edge.render({
                    target: this.$.networkLayout.$.scaleFrontGroup
                });
            }

            this.$.networkLayout.appendDom();
        },
        importVertexAttributeManager: function(columns, attributes) {
            for (var i = 0; i < attributes.length; i++) {
                var row = attributes[i];
                var vertex = this.graph.getVertexById(row.id);
                if (vertex) {
                    for (key in row) {
                        vertex.attributes[key] = row[key];
                    }
                }
            }

            this._addColumns(columns, 'vertexColumns');
            //            this.$.nodeRender.refreshAttributes();

            this.handleVertexDefaultXAttribute();
            this.handleVertexDefaultYAttribute();
        },
        _getNewColumns: function(newColumns, columns) {
            var found;
            var columnsToAdd = [];
            for (var i = 0; i < newColumns.length; i++) {
                var newColumn = newColumns[i];
                found = false;
                for (var j = 0; j < columns.length; j++) {
                    var column = columns[j];
                    if (newColumn.name === column.name) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    columnsToAdd.push(newColumn);
                }
            }
            return columnsToAdd;
        },
        _addColumns: function(newColumns, path) {
            var toAddColumns = this._getNewColumns(newColumns, this[path]);
            this.set(path, this[path].concat(toAddColumns));
        },
        importEdgeAttributeManager: function(columns, attributes) {
            for (var i = 0; i < attributes.length; i++) {
                var row = attributes[i];
                var edge = this.graph.getEdgeById(row.id);
                if (edge) {
                    for (key in row) {
                        edge.attributes[key] = row[key];
                    }
                }
            }
            this._addColumns(columns, 'edgeColumns');

            //            this.$.edgeRender.refreshAttributes();
        },
        __iliketomoveit: function() {
            this.setLayout('Force directed (simulation)');
        },
        handleLoadExampleMenu: function(e) {
            var me = this;
            if (e.detail.subvalue == 1) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                };
                request.open('GET', './example-files/ppi_histone_network.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 2) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.setLayout("Force directed");
                };
                request.open('GET', './example-files/RAF_MAK_kinase_cascade.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 3) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.setLayout("Force directed");
                };
                request.open('GET', './example-files/mutational_landscape_oncogenes_and_tumor_suppressors.json.gz', true);
                request.send();
            }
            if (e.detail.subvalue == 4) {
                var request = new XMLHttpRequest();
                request.responseType = 'arraybuffer';
                request.onload = function() {
                    var jsonStr = pako.ungzip(this.response, {
                        to: 'string'
                    });
                    me.loadJSON(JSON.parse(jsonStr));
                    me.setLayout("Force directed");
                };
                request.open('GET', './example-files/ppi_network.json.gz', true);
                request.send();
            }
        },
        loadSif: function(sifString) {
            var graph;
            new SIFNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(sifString),
                handlers: {
                    'data:load': function(event) {
                        graph = event.graph;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.setGraph(graph);
        },
        loadText: function(textString, sourceCol, targetCol, relationCol, relationDefaultName) {
            var graph;
            new TextNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(textString),
                handlers: {
                    'data:load': function(event) {
                        var adapter = event.sender;
                        graph = adapter.parseColumns(sourceCol, targetCol, relationCol, relationDefaultName);
                        // graph = adapter.parseColumns(0, 1, -1, "r");
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.setGraph(graph);
        },
        loadNodeAttributes: function(attrString) {
            var e;
            new AttributeNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(attrString),
                handlers: {
                    'data:load': function(event) {
                        e = event;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.importVertexAttributeManager(e.columns, e.attributes);
        },
        loadEdgeAttributes: function(attrString) {
            var e;
            new AttributeNetworkDataAdapter({
                async: false,
                dataSource: new StringDataSource(attrString),
                handlers: {
                    'data:load': function(event) {
                        e = event;
                    },
                    'error:parse': function(event) {
                        console.log(event)
                    }
                }
            });
            this.importEdgeAttributeManager(e.columns, e.attributes);
        }
    });
</script>
